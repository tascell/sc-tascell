#/bin/env perl
use strict;
use IO::Handle;
use Getopt::Long qw(:config posix_default no_ignore_case gnu_compat);

sub help {
    print <<'EOS';
    
    timechart.pl: Read all <prefix>-<nnnn>.dat files generated by Tascell worker with the -T option where <nnnn> is a worker id (0000-9999) and generate a timechart graph as an eps file <prefix>.eps.
        
    Usage:
        
        perl timechart.pl <prefix> [options]
        
    Options:
        
        --keep: keep all plot files and a gnuplot script after execution.
        --ignore [regexp]+: graphs for states / events whose names match this regexp are not printed.
        (e.g., "--ignore EV" to ignore events and print only time chart)

EOS
    exit (1);
}

### Get Command-line options
# Prefix of input/output files.
my $prefix = shift (@ARGV);
if ($prefix eq '') {
    print "No <prefix> is specified.\n";
    help();
}

# States / events whose names match this regexp are not printed.
my @Ignore_regexp = ();
# Keep plot files and gnuplot script? (-k option)
my $keep_files = 0;
# Help
my $help = 0;

GetOptions (
    'ignore=s@' => \@Ignore_regexp,
    'keep!' => \$keep_files,
    'help|?' => \$help,
    ) or help();
help() if $help;

if ( $keep_files ) {
    print "Keep-file option is enabled.\n";
}

# States (equivalent to tcounter-strings in worker.sh)
my @Tcounter=("TCOUNTER-INIT","TCOUNTER-EXEC","TCOUNTER-SPWN",
	      "TCOUNTER-WAIT","TCOUNTER-EXCP","TCOUNTER-EXCP-WAIT",
	      "TCOUNTER-ABRT","TCOUNTER-ABRT-WAIT",
	      "TCOUNTER-TREQ-BK","TCOUNTER-TREQ-ANY");
# Events (eqivalent to ev-strings in worker.sh)
my @Evcounter = ("EV-SEND-TASK","EV-STRT-TASK","EV-RSLT-TASK","EV-EXCP-TASK","EV-ABRT-TASK");

# Color for each state/event.
my %Color = ();
$Color{'TCOUNTER-INIT'} = '"black"';
$Color{'TCOUNTER-EXEC'} = '"green"';
$Color{'TCOUNTER-SPWN'} = '"magenta"';
$Color{'TCOUNTER-WAIT'} = '"dark-green"';
$Color{'TCOUNTER-EXCP'} = '"orange"';
$Color{'TCOUNTER-EXCP-WAIT'} = '"dark-orange"';
$Color{'TCOUNTER-ABRT'} = '"red"';
$Color{'TCOUNTER-ABRT-WAIT'} = '"dark-red"';
$Color{'TCOUNTER-TREQ-BK'} = '"dark-khaki"';
$Color{'TCOUNTER-TREQ-ANY'} = '"khaki"';
$Color{'EV-SEND-TASK'} = '"magenta"';
$Color{'EV-STRT-TASK'} = '"green"';
$Color{'EV-RSLT-TASK'} = '"green"';
$Color{'EV-EXCP-TASK'} = '"orange"';
$Color{'EV-ABRT-TASK'} = '"red"';

# Point type for each event.
my %Ptype = ();
$Ptype{'EV-SEND-TASK'} = 6;
$Ptype{'EV-STRT-TASK'} = 66;
$Ptype{'EV-RSLT-TASK'} = 67;
$Ptype{'EV-EXCP-TASK'} = 67;
$Ptype{'EV-ABRT-TASK'} = 67;

# Offset of location of points (y-axis) for each event.
my %Offset = ();
$Offset{'EV-SEND-TASK'} = 0;
$Offset{'EV-STRT-TASK'} = 0.2;
$Offset{'EV-RSLT-TASK'} = -0.2;
$Offset{'EV-EXCP-TASK'} = -0.2;
$Offset{'EV-ABRT-TASK'} = -0.2;

# Title in legend for each state/event.
my %Title = ();
foreach my $stat (@Tcounter, @Evcounter) {
    my $tit = $stat;
    if ($stat =~ /TCOUNTER-(\S+)/) {
	$tit = $1;
    }
    if ($stat =~ /EV-(\S+)/) {
	$tit = $1;
    }
    $Title{$stat} = $tit;
}

# Plot file name for each state/event.
my %Plot_file = ();
# File handler for each state/event.
my %Plot_file_fp = ();
# Whether there is any plot data for each state/event?
my %Valid = ();


# Max of xrange (depends on max number of end time)
my $x_max = 0;
# Max of yrange (depends on the number of workers)
my $y_max = 0;

# Directory to save all generated files
my $dirname = "$prefix-plot";

# eps file to be created
my $fname_eps = "$prefix.eps";

# Scan log files generated by Tascell workers
my @Files = ();
foreach my $i (0 .. 9999) {
    my $fname = sprintf ("$prefix-%04d.dat", $i);
    if ( -e $fname ) {
	print "$fname\n";
	push (@Files, $fname);
    } elsif ($i>0) {
	print ($i." log files found.\n");
	$y_max = $i;
	last;
    } else {
	print "No log files named $prefix-<nnnn>.dat found.\n";
	exit 99;
    }
}

# Gnuplot script file
my $fname_gp = "plot.gnuplot";


### Main
# Make directory
mkdir $dirname or die "Failed to generate $dirname";

# Open a plot file for each status/evnet to be written
foreach my $stat (@Tcounter, @Evcounter) {
    $Plot_file{$stat} = "$prefix-$stat.plt";
    my $pltfile = "$dirname/$Plot_file{$stat}";
    open ($Plot_file_fp{$stat}, "> $pltfile") or die "Failed to write a plot file $pltfile";
}

# Read log files and write to plot files.
foreach my $stat (@Tcounter, @Evcounter) { $Valid{$stat} = 0; }
my $id = -1;
foreach my $file (@Files) {
    $id++;
    open (FP, "< $file") or die "Failed to open $file.";
    while (my $line = <FP>) {
        # status + time range?
        if ($line =~ /^\s*(\S+)\s+(\S+)\s+(\S+)/) {
            my ($l_stat, $start, $end) = ($1, $2, $3);
            foreach my $stat (@Tcounter) {
		if ($l_stat eq $stat) {
		    $Valid{$stat} = 1;
		    if ($end > $x_max) { $x_max = $end; }
                    $Plot_file_fp{$stat}->print("$start $id\n");
		    $Plot_file_fp{$stat}->print("$end $id\n");
		    $Plot_file_fp{$stat}->print("\n");
                    goto LINE_END;
		}
            }
        }
        # event + event time?
        if ($line =~ /^\s*(\S+)\s+(\S+)/) {
            my ($l_ev, $evtime) = ($1, $2);
            foreach my $ev (@Evcounter) {
		if ($l_ev eq $ev) {
                    $Valid{$ev} = 1;
                    if ($evtime > $x_max) { $x_max = $evtime; }
                    my $py = $id + $Offset{$ev};
                    $Plot_file_fp{$ev}->print("$evtime $py\n");
                    goto LINE_END;
                }
            }
        }
      LINE_END: ;
    }
    close (FP);
}

# Close a plot files
foreach my $stat (@Tcounter, @Evcounter) {
    close ($Plot_file_fp{$stat});
}

# Handle --ignore option
foreach my $stat (@Tcounter, @Evcounter) {
    foreach my $reg (@Ignore_regexp) {
        if ( $stat =~ $reg ) {
            $Valid{$stat} = 0;
            print "$stat is not printed due to --ignore $reg option\n";
            last;
        }
    }
}

# Run gnuplot to generate an eps file and make a gnuplot script file
# with which the same eps file can be generated again.
open (GP, "| gnuplot" ) or die "Failed to exeute gnuplot";
open (FP_GP, "> $dirname/$fname_gp") or die "Failed to open $dirname/$fname_gp to write";
sub print_gp {
    my $str = shift;
    print GP $str;
    print FP_GP $str;
    print $str;
}
#print_gp "set key left top font 'Helvetica Neue,10' width 2"."\n";
print_gp "set key left top"."\n";

print_gp "set xrange [-0.25:$x_max]"."\n";
print_gp "set xtics 0, 1, $x_max"."\n";
print_gp 'set xlabel "time [s]"'."\n";

print_gp "set yrange [-1:$y_max]"."\n";
print_gp "set ytics 0, 1, ".($y_max-1)."\n";
print_gp 'set ylabel "worker ID"'."\n";

print_gp 'set terminal postscript eps enhanced color'."\n";
print_gp "set output \"$fname_eps\""."\n";

my $replot = 0;
foreach my $stat (@Tcounter) {
    if ($Valid{$stat}) {
	print_gp (($replot==0)?'plot ':", \\\n");
	print_gp "\"$dirname/$Plot_file{$stat}\" w l lc rgb $Color{$stat} lt 1 linewidth 5 title \"$Title{$stat}\"";
	$replot = 1;
    }
}
foreach my $ev (@Evcounter) {
    if ($Valid{$ev}) {
	print_gp (($replot==0)?'plot ':", \\\n");
	print_gp "\"$dirname/$Plot_file{$ev}\" w p lc rgb $Color{$ev} pt $Ptype{$ev} ps 0.7 title \"$Title{$ev}\"";
	$replot = 1;
    }
}
print_gp "\n";

# Close gnuplot process and script
close (GP);
close (FP_GP);

unless ($keep_files) {
# remove plot files
    foreach my $stat (@Tcounter, @Evcounter) {
	unlink "$dirname/$Plot_file{$stat}";
    }
# remove gnuplot script
    unlink "$dirname/$fname_gp";
# remove directory
    rmdir $dirname;
}

# Show summary
print "* * * Summary * * *\n";
if ( -e $fname_eps ) {
    print "An eps file $fname_eps generated.\n";
}
if ( -d $dirname ) {
    print "Plot files and a gnuplot script file are stored in $dirname/.\n";
    print "You can generate $fname_eps again by:\n";
    print "\$ gnuplot $dirname/$fname_gp\n";
}
