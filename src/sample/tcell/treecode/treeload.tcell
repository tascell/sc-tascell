;;;
;;; treeload.tcell
;;;   created by Ken Matsui <kmatsui@kuis.kyoto-u.ac.jp>
;;;

;; This file will be included to treecode.tcell
;; when building for shared memory environments.


;------------------------------------------------------------------------------
; declarations of functions and global variables
;------------------------------------------------------------------------------

(%defconstant MAXLEVEL 32)

(extern options string)
(extern usequad bool)
(extern root cellptr)
(extern rsize real)
(extern tdepth int)
(extern cputree real)

(extern bh86 bool)
(extern sw94 bool)
(extern cellhist (array int MAXLEVEL))
(extern subnhist (array int MAXLEVEL))


(decl (subindex p q)
      (fn int bodyptr cellptr))
(decl (setrcrit p cmpos psize)
      (fn void cellptr vector real))
(decl (hackquad p)
      (fn void cellptr))

(decl (newtree)
      (wfn void))
(decl (newtree-for p i1 i2)
      (wfn void cellptr int int))
(decl (makecell)
      (wfn cellptr))
(decl (collectcell c)
      (wfn void cellptr))
(decl (expandbox btab nbody)
      (wfn void bodyptr int))
(decl (expandbox-for btab i1 i2)
      (wfn real bodyptr int int))
(decl (loadbody p q qsize)
      (wfn void bodyptr cellptr real))
(decl (load-all-bodies)
      (wfn void))
(decl (hackcofm p psize lev)
      (wfn void cellptr real int))
(decl (threadtree p n)
      (wfn void nodeptr nodeptr))
(decl (threadtree-for desc i1 i2)
      (wfn void (array nodeptr (+ NSUB 1)) int int))


;------------------------------------------------------------------------------
; maketree
;------------------------------------------------------------------------------

(def (maketree btab nbody)
     (wfn void bodyptr int)
    (def i int)
    (def q cellptr)
    (def cpustart double)
    (def tp (array (struct timeval) 2))
    
    (= cpustart (csym::cputime))
  
    (csym::gettimeofday tp 0)
    (newtree)
    (csym::gettimeofday (+ tp 1) 0)
    (+= nwtreetime (csym::elapsed-time tp))
    
    (= root (makecell))
    (csym::CLRV (csym::Pos root))
    
    (csym::gettimeofday tp 0)
    (expandbox btab nbody)
    (csym::gettimeofday (+ tp 1) 0)
    (+= expandtime (csym::elapsed-time tp))
    
    (csym::gettimeofday tp 0)
    (load-all-bodies)
    (csym::gettimeofday (+ tp 1) 0)
    (+= crtreetime (csym::elapsed-time tp))

    (%if* (or (eq 'MKTREE-METHOD 'SS-PROB)
              (eq 'MKTREE-METHOD 'MERGE-PROB))
        (for ((= i 0) (< i num-thrs) (inc i))
            (= (fref (cast (ptr (struct thread-data)) (+ threads i)) -> probability)
               1.0)
            )
        )
    (= bh86 (scanopt options "bh86"))
    (= sw94 (scanopt options "sw94"))
    (if (and bh86 sw94)
        (csym::error "maketree: incompatible options bh86 and sw94~%")
        )
    
    (csym::gettimeofday tp 0)
    (= tdepth 0)
    (for ((= i 0) (< i MAXLEVEL) (inc i))
        (= (aref cellhist i) 0)
        (= (aref subnhist i) 0))
    (hackcofm root rsize 0)
    (csym::gettimeofday (+ tp 1) 0)
    (+= hackcmtime (csym::elapsed-time tp))
    
    (csym::gettimeofday tp 0)
    (threadtree (cast nodeptr root) NULL)
    (csym::gettimeofday (+ tp 1) 0)
    (+= threadtime (csym::elapsed-time tp))
    
    (if usequad
        (hackquad root)
        )
    (= cputree (- (csym::cputime) cpustart))
    )


;------------------------------------------------------------------------------
; nwtree: task definition for parallelizing newtree
;------------------------------------------------------------------------------

(def (task nwtree)
    (def p cellptr)
    (def i1 int)
    (def i2 int)
    )

(def (task-body nwtree)
    (newtree-for this.p this.i1 this.i2)
    )

(def (newtree)
     (wfn void)
    (static firstcall bool TRUE)
    
    (if firstcall
        (begin
        (= firstcall FALSE)
        (= old-root NULL)
        )
        (begin
        (%if* (eq (or 'MKTREE-METHOD 'MERGE)
                  (or 'MKTREE-METHOD 'MERGE-PROB))
            (if old-root
                (begin
                (newtree-for old-root 0 NSUB)
                (= (csym::Next old-root) (cast nodeptr WDATA.freecell))
                (= WDATA.freecell old-root)
                ))
            (= old-root root)
         %else
            (newtree-for root 0 NSUB)
            (= (csym::Next root) (cast nodeptr WDATA.freecell))
            (= WDATA.freecell root)
            )
        ))
    (= root NULL)
    (= ncell 0)
    )

(def (newtree-for p i1 i2)
     (wfn void cellptr int int)
    (do-many for i from i1 to i2
        (begin
        (def subp nodeptr (aref (csym::Subp p) i))
        (if (and (!= subp NULL)
                 (== (csym::Type subp) CELL))
            (begin
            (newtree-for (cast cellptr subp) 0 NSUB)
            (= (csym::Next subp) (cast nodeptr WDATA.freecell))
            (= WDATA.freecell (cast cellptr subp))
            ))
        )
    (nwtree
        (:put from j1 to j2
        (= this.p p)
        (= this.i1 j1)
        (= this.i2 j2)
        )
        (:get
        )))
    )


;------------------------------------------------------------------------------
; makecell
;------------------------------------------------------------------------------

(def (makecell)
     (wfn cellptr)
    (def i int)
    (def ret cellptr)
    (if (== WDATA.pool NULL)
        (begin
        (= WDATA.pool-size (/ nbody 32))
        (= WDATA.pool (csym::allocate (* WDATA.pool-size (sizeof cell))))
        ))
    (if (!= WDATA.freecell NULL)
        (begin
        (= ret WDATA.freecell)
        (= WDATA.freecell (cast cellptr (csym::Next ret)))
;       (csym::memset ret 0 (sizeof cell))
        )
        (begin
        (if (== WDATA.pool-used WDATA.pool-size)
            (begin
            (= WDATA.pool (csym::allocate (* WDATA.pool-size (sizeof cell))))
            (= WDATA.pool-used 0)
            ))
        (= ret (+ WDATA.pool (inc WDATA.pool-used)))
        ))
    (= (csym::Type ret) CELL)
    (= (csym::Update ret) FALSE)
    (for ((= i 0) (< i NSUB) (inc i))
        (= (aref (csym::Subp ret) i) NULL)
        )
    (%if* (eq 'MKTREE-METHOD 'LOCK)
        (csym::pthread-mutex-init (ptr ret->mx) NULL)
        )
    (return ret)
    )

(def (collectcell c)
     (wfn void cellptr)
    (= (csym::Next c) (cast nodeptr WDATA.freecell))
    (= WDATA.freecell c)
    )

;------------------------------------------------------------------------------
; expand: task definition for parallelizing expandbox
;------------------------------------------------------------------------------

(def (task expand)
    (def btab bodyptr :in)
    (def i1 int :in)
    (def i2 int :in)
    (def dmax real :out)
    )

(def (task-body expand)
    (= this.dmax (expandbox-for this.btab this.i1 this.i2))
    )

(def (expandbox btab nbody)
     (wfn void bodyptr int)
    (def dmax real (expandbox-for btab 0 nbody))
    (while (< rsize (* 2 dmax))
        (= rsize (* 2 rsize))
        )
    )

(def (expandbox-for btab i1 i2)
     (wfn real bodyptr int int)
    (def dmax real 0.0)
    (do-many for i from i1 to i2
        (begin
        (def k int)
        (def d real)
        (def p bodyptr (+ btab i))
        (for ((= k 0) (< k NDIM) (inc k))
            (= d (csym::rabs (- (aref (csym::Pos p) k) (aref (csym::Pos root) k))))
            (if (> d dmax)
                (= dmax d)
                )
            )
        )
    (expand
        (:put from j1 to j2
        (= this.btab btab)
        (= this.i1 j1)
        (= this.i2 j2)
        )
        (:get
        (if (> this.dmax dmax)
            (= dmax this.dmax))
        )))
    (return dmax)
    )


;------------------------------------------------------------------------------
; loadbody
;------------------------------------------------------------------------------

(def (loadbody p q qsize)
     (wfn void bodyptr cellptr real)
    (def k int)
    (def qind int)
    
    (= qind (csym::subindex p q))
    (%if* (eq 'MKTREE-METHOD 'LOCK)
        (csym::pthread-mutex-lock (ptr q->mx)))
    (while (!= (aref (csym::Subp q) qind) NULL)
;       (def oldq cellptr)
        (if (== (csym::Type (aref (csym::Subp q) qind)) BODY)
            (begin
            (def c cellptr)
            (def dist2 real)
            (def distv vector)
            (csym::DOTPSUBV dist2 distv (csym::Pos p) (csym::Pos (aref (csym::Subp q) qind)))
            (if (== dist2 0.0)
                (csym::error "loadbody: two bodies have same position~%")
                )
            (= c (makecell))
            (for ((= k 0) (< k NDIM) (inc k))
                (= (aref (csym::Pos c) k)
                   (+ (aref (csym::Pos q) k)
                      (/ (if-exp (< (aref (csym::Pos p) k) (aref (csym::Pos q) k))
                                 (- qsize) qsize) 4)))
                )
;            (for ((= k 0) (< k NDIM) (inc k))
;                (if (or (<  (aref (csym::Pos (aref (csym::Subp q) qind)) k) (- (aref (csym::Pos c) k) (/ qsize 4)))
;                        (>= (aref (csym::Pos (aref (csym::Subp q) qind)) k) (+ (aref (csym::Pos c) k) (/ qsize 4))))
;                    (csym::error "loadbody: body is outside of cell.")
;                    )
;                )
            (= (aref (csym::Subp c) (csym::subindex (cast bodyptr (aref (csym::Subp q) qind)) c))
               (aref (csym::Subp q) qind))
            (= (aref (csym::Subp q) qind) (cast nodeptr c))
            ))
;       (= oldq q)
        (%if* (eq 'MKTREE-METHOD 'LOCK)
            (csym::pthread-mutex-unlock (ptr q->mx)))
        (= q (cast cellptr (aref (csym::Subp q) qind)))
        (= qind (csym::subindex p q))
        (= qsize (/ qsize 2))
        (%if* (eq 'MKTREE-METHOD 'LOCK)
            (csym::pthread-mutex-lock (ptr q->mx)))
        )
    (for ((= k 0) (< k NDIM) (inc k))
        (if (or (<  (aref (csym::Pos p) k) (- (aref (csym::Pos q) k) (/ qsize 2)))
                (>= (aref (csym::Pos p) k) (+ (aref (csym::Pos q) k) (/ qsize 2))))
            (csym::error "loadbody: body is outside of cell.")
            )
        )
    (= (aref (csym::Subp q) qind) (cast nodeptr p))
    (%if* (eq 'MKTREE-METHOD 'LOCK)
        (csym::pthread-mutex-unlock (ptr q->mx)))
    )


;------------------------------------------------------------------------------
; load: task definition for inserting bodies into the root cell
;------------------------------------------------------------------------------

(%if* (eq 'MKTREE-METHOD 'LOCK)
; =========================================================================
;;; Load bodies using pthread_mutex_t

(decl (load-all-bodies-for start end)
      (wfn void int int))

(def (task load)
    (def i1 int)
    (def i2 int)
    )

(def (task-body load)
    (load-all-bodies-for this.i1 this.i2)
    )

(def (load-all-bodies)
     (wfn void)
    (load-all-bodies-for 0 nbody)
    )

(def (load-all-bodies-for start end)
     (wfn void int int)
    (do-many for i from start to end
        (begin
        (def p bodyptr (+ bodytab i))
        (loadbody p root rsize)
        )
    (load
        (:put from j1 to j2
        (= this.i1 j1)
        (= this.i2 j2)
        )
        (:get
        )))
;    (if (< (- end start) 8)
;        (begin
;        (def i int)
;        (for ((= i start) (< i end) (inc i))
;            (def p bodyptr (+ bodytab i))
;            (loadbody p root rsize)
;            )
;        )
;        (begin
;        (do-two
;            (load-all-bodies-dc start (+ start (/ (- end start) 2)))
;            (load-all-bodies-dc (+ start (/ (- end start) 2)) end)
;        (load
;            (:put
;            (= this.i1 (+ start (/ (- end start) 2)))
;            (= this.i2 end)
;            )
;            (:get
;            )))
;        ))
    )

%else (%if* (or (eq 'MKTREE-METHOD 'SS)
                (eq 'MKTREE-METHOD 'SS-PROB))
; =========================================================================
;;; Load bodies by space stealing method

;(decl (mergecell to from size)
;      (wfn void cellptr cellptr real))
;(decl (mergecell-for to from size i1 i2)
;      (wfn void cellptr cellptr real int int))
(decl (load-all-bodies-for p-start q-start qsize minrange maxrange)
      (wfn void bodyptr cellptr real vector vector))

(def (task load)
    (def p-start bodyptr)
    (def q-start cellptr)
    (def qsize real)
    (def minrange vector)
    (def maxrange vector)
    )

(def (task-body load)
    (%ifdef* MKTREE-PROFILE
        (inc WDATA.received-task)
        )
    (if (== this.p-start NULL)
        (begin
        (%ifdef* MKTREE-PROFILE
            (inc WDATA.failed-task)
            )
        (return)
        ))
    (load-all-bodies-for
        this.p-start this.q-start this.qsize this.minrange this.maxrange)
    )

(def (load-all-bodies)
     (wfn void)
    (def i int)
    (def minrange vector)
    (def maxrange vector)
    (for ((= i 0) (< i NDIM) (inc i))
        (= (aref minrange i) (/ (- rsize) 2))
        (= (aref maxrange i) (/ rsize 2))
        )
    (load-all-bodies-for bodytab root rsize minrange maxrange)
    )

(def (hacksubcell q qsize minrange maxrange)
     (wfn cellptr cellptr real vector vector)
    (def k int)
    (def cofnq vector)
    (for ((= k 0) (< k NDIM) (inc k))
        (= (aref cofnq k) (+ (aref minrange k)
                             (/ (- (aref maxrange k) (aref minrange k)) 2)))
        )

;;  (for ((= k 0) (< k NDIM) (inc k))
;;      (if (not (and (<= (- (aref (csym::Pos q) k) (/ qsize 4)) (aref cofnq k))
;;                    (<= (aref cofnq k) (+ (aref (csym::Pos q) k) (/ qsize 4)))))
;;          (csym::error "Assertion Failed: cofnq is inner point of cell q~%")
;;          )
;;      )

    (def ind int 0)
    (for ((= k 0) (< k NDIM) (inc k))
        (if (<= (aref (csym::Pos q) k) (aref cofnq k))
            (+= ind (>> NSUB (+ k 1)))
            )
        )

    (def nq nodeptr (aref (csym::Subp q) ind))
    (if (== nq NULL)
        (begin
        (= nq (cast nodeptr (makecell)))
        (csym::SETV (csym::Pos nq) cofnq)
        )
        (if (== (csym::Type nq) BODY)
            (begin
            (def b bodyptr (cast bodyptr nq))
            (def c cellptr (makecell))
            (csym::SETV (csym::Pos c) cofnq)
            (loadbody b c (/ qsize 2))
            (= nq (cast nodeptr c))
            )
;;          (begin
;;          (for ((= k 0) (< k NDIM) (inc k))
;;              (if (!= (aref (csym::Pos nq) k) (aref cofnq k))
;;                  (csym::error "Assertion Failed: cofnq should match with existing cell.~%")
;;                  )
;;              )
;;          )
            )
        )
    (= (aref (csym::Subp q) ind) nq)
  
;;  (if (!= (csym::Type nq) CELL)
;;        (csym::error "Assertion Failed: Type(nq) == CELL~%")
;;        )
    (return (cast cellptr nq))
    )


(def (load-all-bodies-for p-start q-start qsize minrange maxrange)
     (wfn void bodyptr cellptr real vector vector)
    (def POLLING-INTERVAL int 4)
    (def p bodyptr)
    (%ifdef* MKTREE-PROFILE
        (def tp (array (struct timespec) 2))
        (csym::clock-gettime CLOCK_REALTIME tp)
        )

    (def checked-bodies int 1)
    (def inserted-bodies int 1)
    
    (do-many* ((= p p-start) (< p (+ bodytab nbody)) (+= p POLLING-INTERVAL))
        (begin
        (def i int)
        (%if* (eq 'MKTREE-METHOD 'SS-PROB)
            (= PROBABILITY (/ (cast double inserted-bodies) (cast double checked-bodies)))
            ; threshold based probability
            ;(if (< (/ (cast double inserted-bodies) (cast double checked-bodies)) 0.25)
            ;  (= PROBABILITY 0.0)
            ;  (= PROBABILITY 1.0))
            )
        (for ((= i 0) (< i POLLING-INTERVAL) (inc i)) 
            (begin
            (def -p bodyptr (+ p i))
            (if (>= -p (+ bodytab nbody))
                (break)
                )
            (inc checked-bodies)
            ; ======== for profiling ========
            (%ifdef* MKTREE-PROFILE
                (def tc (array (struct timespec) 2))
                (csym::clock-gettime CLOCK_REALTIME tc)
                
                (inc WDATA.received-bodies)
                )
            ; ======== range check ========
            (def j int)
            (def over int 0)
            (for ((= j 0) (< j NDIM) (inc j))
                (if (or (<  (aref (csym::Pos -p) j) (aref minrange j))
                        (>= (aref (csym::Pos -p) j) (aref maxrange j)))
                    (begin
                    (= over 1)
                    (break)
                    ))
                )
            (%ifdef* MKTREE-PROFILE
                (csym::clock-gettime CLOCK_REALTIME (+ tc 1))
                )
            ; ======== inserts a body if in range ========
            (if (not over)
                (begin
                (%ifdef* MKTREE-PROFILE
                    (+= WDATA.checking-time
                        (+ (- (fref (aref tc 1) tv_nsec) (fref (aref tc 0) tv_nsec))
                           (* (- (fref (aref tc 1) tv_sec) (fref (aref tc 0) tv_sec)) 1000000000)))
                    (def ti (array (struct timespec) 2))
                    (inc WDATA.inserted-bodies)
                    (csym::clock-gettime CLOCK_REALTIME ti)
                    )

                (inc inserted-bodies)
                (loadbody -p q-start qsize)

                (%ifdef* MKTREE-PROFILE
                    (csym::clock-gettime CLOCK_REALTIME (+ ti 1))
                    (+= WDATA.inserting-time (+ (- (fref (aref ti 1) tv_nsec) (fref (aref ti 0) tv_nsec))
                                  (* (- (fref (aref ti 1) tv_sec) (fref (aref ti 0) tv_sec)) 1000000000)))
                    )
                )
                (begin
                (%ifdef* MKTREE-PROFILE
                    (+= WDATA.redundant-time
                        (+ (- (fref (aref tc 1) tv_nsec) (fref (aref tc 0) tv_nsec))
                           (* (- (fref (aref tc 1) tv_sec) (fref (aref tc 0) tv_sec)) 1000000000)))
                    )
                ))
            ))
        )
    (load
        (:put
        (%ifdef* MKTREE-PROFILE
            (def td (array (struct timespec) 2))
            (csym::clock-gettime CLOCK_REALTIME td)
            )
       ; (%if* (eq 'MKTREE-METHOD 'SS-PROB)
       ;     ;(def root-volume real (* (* rsize rsize) rsize)) 
       ;     ;(def curr-volume real (* (* (- (aref maxrange 0) (aref minrange 0))
       ;     ;                            (- (aref maxrange 1) (aref minrange 1)))
       ;     ;                         (- (aref maxrange 2) (aref minrange 2))))
       ;     ;(def prob real (/ curr-volume root-volume))
       ;     (def prob real (/ (cast real inserted-bodies) (cast real checked-bodies)))
       ;     (if (< (csym::xrandom 0.0 1.0) prob)
       ;         (= this.p-start p)
       ;         (= this.p-start NULL)
       ;         )
       ;  %else 
            (= this.p-start p)
       ;     )
        
        (if (!= this.p-start NULL)
            (begin
            (= this.q-start q-start)
            (= this.qsize qsize)
            (csym::SETV this.minrange minrange)
            (csym::SETV this.maxrange maxrange)
            (def xsize real (- (aref maxrange 0) (aref minrange 0)))
            (def ysize real (- (aref maxrange 1) (aref minrange 1)))
            (def zsize real (- (aref maxrange 2) (aref minrange 2)))
            (def MINSIZE-THRESHOLD real 0.00001)
            (if (and (> xsize ysize) (> xsize zsize))
                (begin
                (if (>= xsize (* MINSIZE-THRESHOLD 2.0))
                    (begin
                    (= (aref maxrange 0) (+ (aref minrange 0) (/ xsize 2.0)))
                    (= (aref this.minrange 0) (aref maxrange 0))
                    )
                    (= this.p-start NULL)
                    ))
                (if (> ysize zsize)
                    (begin
                    (if (>= ysize (* MINSIZE-THRESHOLD 2.0))
                        (begin
                        (= (aref maxrange 1) (+ (aref minrange 1) (/ ysize 2.0)))
                        (= (aref this.minrange 1) (aref maxrange 1))
                        )
                        (= this.p-start NULL)
                        ))
                    (begin
                    (if (>= zsize (* MINSIZE-THRESHOLD 2.0))
                        (begin
                        (= (aref maxrange 2) (+ (aref minrange 2) (/ zsize 2.0)))
                        (= (aref this.minrange 2) (aref maxrange 2))
                        )
                        (= this.p-start NULL)
                        ))
                    )
                )
            (if (!= this.p-start NULL)
;            (def k int)
;            (def under int 0)
;            (for ((= k 0) (< k NDIM) (inc k))
;                (if (< (- (aref this.maxrange k) (aref this.minrange k)) 0.00001)
;                    (begin
;                    (= under 1)
;                    (break)
;                    ))
;                )
;            (if under
;                (begin
;                (= this.p-start NULL)
;                (for ((= k 0) (< k NDIM) (inc k))
;                    (= (aref maxrange k) (aref this.maxrange k))
;                    )
;                )
                (if (and (> xsize ysize) (> xsize zsize))
                    (begin
                    ; ======== space decomposition hack for theif ========
                    (= this.q-start (hacksubcell q-start qsize this.minrange this.maxrange))
                    (/= this.qsize 2)
                    ; ======== space decomposition hack for victim ========
                    (= q-start (hacksubcell q-start qsize minrange maxrange))
                    (/= qsize 2)
                    ))
                )
            ))
        (%ifdef* MKTREE-PROFILE
            (csym::clock-gettime CLOCK_REALTIME (+ td 1))
            (+= WDATA.task-dividing-time
                (+ (- (fref (aref td 1) tv_nsec) (fref (aref td 0) tv_nsec))
                   (* (- (fref (aref td 1) tv_sec) (fref (aref td 0) tv_sec)) 1000000000)))
            )
        )
        (:get
        )))
    (%ifdef* MKTREE-PROFILE
        (csym::clock-gettime CLOCK_REALTIME (+ tp 1))
        (+= WDATA.working-time (+ (- (fref (aref tp 1) tv_nsec) (fref (aref tp 0) tv_nsec))
                                  (* (- (fref (aref tp 1) tv_sec) (fref (aref tp 0) tv_sec)) 1000000000)))
        )
    )

%else (%if* (or (eq 'MKTREE-METHOD 'MERGE)
                (eq 'MKTREE-METHOD 'MERGE-PROB))
; =========================================================================
;;; Load bodies by merging method

(decl (mergetree lhd rhd csize)
      (wfn void cellptr cellptr real))
(decl (load-all-bodies-core local-root traverse start end)
      (wfn void cellptr cellptr int int))

(def (task load)
    (def local-root cellptr)
    (def traverse-root cellptr)
    (def start int)
    (def end int)
    )

(def (task-body load)
    (%ifdef* MKTREE-PROFILE
        (def td (array (struct timespec) 2))
        (inc WDATA.received-task)
        (csym::clock-gettime CLOCK_REALTIME td)
        )
    (load-all-bodies-core this.local-root this.traverse-root
                          this.start this.end)
    (%ifdef* MKTREE-PROFILE
        (csym::clock-gettime CLOCK_REALTIME (+ td 1))
        (+= WDATA.working-time
            (+ (- (fref (aref td 1) tv_nsec) (fref (aref td 0) tv_nsec))
               (* (- (fref (aref td 1) tv_sec) (fref (aref td 0) tv_sec)) 1000000000)))
        )
    )

(def (load-all-bodies)
     (wfn void)
    (def bin int nbody)
    (%ifdef* MKTREE-PROFILE
        (def td (array (struct timespec) 2))
        (inc WDATA.received-task)
        (csym::clock-gettime CLOCK_REALTIME td)
        )
    (if old-root
        (load-all-bodies-core root old-root 0 NSUB)
        (load-all-bodies-core root old-root 0 nbody)
        )
    (%ifdef* MKTREE-PROFILE
        (csym::clock-gettime CLOCK_REALTIME (+ td 1))
        (+= WDATA.working-time
            (+ (- (fref (aref td 1) tv_nsec) (fref (aref td 0) tv_nsec))
               (* (- (fref (aref td 1) tv_sec) (fref (aref td 0) tv_sec)) 1000000000)))
        )
    )

(def (load-all-bodies-core local-root traverse start end)
     (wfn void cellptr cellptr int int)
    (if traverse
        (begin
        ; ==  An old tree exists, so we construct a new tree by traversing it.
        (%if* (eq 'MKTREE-METHOD 'MERGE-PROB)
            (def i int)
            (def bin int 0)
            (for ((= i start) (< i end) (inc i))
                (if (aref (csym::Subp traverse) i)
                    (if (== (csym::Type (aref (csym::Subp traverse) i)) CELL)
                        (+= bin (csym::Nbody (aref (csym::Subp traverse) i)))
                        (inc bin)
                        )
                    )
                )
            )
        (do-many for i from start to end
            (begin
            (def p nodeptr (aref (csym::Subp traverse) i))
            (if p
                (begin
                (if (== (csym::Type p) BODY)
                    (begin
                    (%ifdef* MKTREE-PROFILE
                        (def ti (array (struct timespec) 2))
                        (inc WDATA.inserted-bodies)
                        (csym::clock-gettime CLOCK_REALTIME ti)
                        )
                    (loadbody (cast bodyptr p) local-root rsize)
                    (%if* (eq 'MKTREE-METHOD 'MERGE-PROB)
                        (dec bin)
                        )
                    (%ifdef* MKTREE-PROFILE
                        (csym::clock-gettime CLOCK_REALTIME (+ ti 1))
                        (+= WDATA.inserting-time
                            (+ (- (fref (aref ti 1) tv_nsec) (fref (aref ti 0) tv_nsec))
                               (* (- (fref (aref ti 1) tv_sec) (fref (aref ti 0) tv_sec)) 1000000000)))
                        )
                    )
                    (begin
                    (load-all-bodies-core local-root (cast cellptr p) 0 NSUB)
                    (%if* (eq 'MKTREE-METHOD 'MERGE-PROB)
                        (-= bin (csym::Nbody p))
                        )
                    ))
                ))
            )
        (load
            (:put from j1 to j2
                (%ifdef* MKTREE-PROFILE
                    (def td (array (struct timespec) 2))
                    (csym::clock-gettime CLOCK_REALTIME td)
                    )
                ;(%if* (eq 'MKTREE-METHOD 'MERGE-PROB)
                ;    (def prob real (/ (cast real (fref traverse -> nbody)) (cast real nbody)))
                ;    (if (< (csym::xrandom 0.0 1.0) prob)
                ;        (begin
                ;        (= this.local-root (makecell))
                ;        (csym::CLRV (csym::Pos this.local-root))
                ;        )
                ;        (begin
                ;        (= this.local-root NULL)
                ;        ))
                ; %else
                    (= this.local-root (makecell))
                    (csym::CLRV (csym::Pos this.local-root))
                ;    )
                (= this.traverse-root traverse)
                (= this.start j1)
                (= this.end j2)

                (%if* (eq 'MKTREE-METHOD 'MERGE-PROB)
                    (def j int)
                    (for ((= j j1) (< j j2) (inc j))
                        (if (aref (csym::Subp traverse) j)
                            (if (== (csym::Type (aref (csym::Subp traverse) j)) CELL)
                                (-= bin (csym::Nbody (aref (csym::Subp traverse) j)))
                                (dec bin)
                                )
                            )
                        ) 
                    (= PROBABILITY (csym::MIN 1.0 (* 4.0 (* (cast double num-thrs) (/ (cast real bin) (cast real nbody))))))
                    ; threshold based probability
                    ;(if (> (* 20.0 (* (cast double num-thrs) (/ (cast real bin) (cast real nbody)))) 1.0)
                    ;  (= PROBABILITY 1.0)
                    ;  (= PROBABILITY 0.0))
                    )
                   ; (def next-start int (- j1 (/ (- j2 j1) 2)))
                   ; (def next-end int j1)
                   ; (def next-traverse nodeptr (cast nodeptr traverse))
                   ; (def bin int 0)
                   ; (if (== (- j2 j1) 1)
                   ;     (begin
                   ;     (= next-start (/ NSUB 2))
                   ;     (= next-end NSUB)
                   ;     (= next-traverse (aref (csym::Subp traverse) (- j1 1)))
                   ;     ))
                   ; (if next-traverse
                   ;     (if (== (csym::Type next-traverse) BODY)
                   ;         (begin
                   ;         (= bin 1)
                   ;         )
                   ;         (begin
                   ;         (for ((= j next-start) (< j next-end) (inc j))
                   ;              (if (aref (csym::Subp next-traverse) j)
                   ;                  (if (== (csym::Type (aref (csym::Subp next-traverse) j)) CELL)
                   ;                      (+= bin (csym::Nbody (aref (csym::Subp next-traverse) j)))
                   ;                      (+= bin 1)
                   ;                      )
                   ;                  )
                   ;             )
                   ;         ))
                   ;     )
                   ; (= PROBABILITY (/ (cast real bin) (cast real nbody)))
                   ; )

                (%ifdef* MKTREE-PROFILE
                    (csym::clock-gettime CLOCK_REALTIME (+ td 1))
                    (+= WDATA.task-dividing-time
                        (+ (- (fref (aref td 1) tv_nsec) (fref (aref td 0) tv_nsec))
                           (* (- (fref (aref td 1) tv_sec) (fref (aref td 0) tv_sec)) 1000000000)))
                    )
                )
            (:get
                (%ifdef* MKTREE-PROFILE
                    (def tf (array (struct timespec) 2))
                    (csym::clock-gettime CLOCK_REALTIME tf)
                    )
                ;(%if* (eq 'MKTREE-METHOD 'MERGE-PROB)
                ;    (if this.local-root
                ;        (begin
                ;        (mergetree local-root this.local-root rsize)
                ;        (collectcell this.local-root)
                ;        ))
                ; %else
                    (mergetree local-root this.local-root rsize)
                    (collectcell this.local-root)
                ;    )
                (%ifdef* MKTREE-PROFILE
                    (csym::clock-gettime CLOCK_REALTIME (+ tf 1))
                    (+= WDATA.rst-merging-time
                        (+ (- (fref (aref tf 1) tv_nsec) (fref (aref tf 0) tv_nsec))
                           (* (- (fref (aref tf 1) tv_sec) (fref (aref tf 0) tv_sec)) 1000000000)))
                    )
                )
            ))
            (%if* (eq 'MKTREE-METHOD 'MERGE-PROB)
                (if bin
                    (csym::error "assertion failure")
                    )
                )
        )
        (begin
        ; ==  This is the first time tree construction.
        (do-many for i from start to end
            (begin
            (def p bodyptr (+ bodytab i))
            (%ifdef* MKTREE-PROFILE
                (def ti (array (struct timespec) 2))
                (inc WDATA.inserted-bodies)
                (csym::clock-gettime CLOCK_REALTIME ti)
                )
            (loadbody p local-root rsize)
            (%ifdef* MKTREE-PROFILE
                (csym::clock-gettime CLOCK_REALTIME (+ ti 1))
                (+= WDATA.inserting-time
                    (+ (- (fref (aref ti 1) tv_nsec) (fref (aref ti 0) tv_nsec))
                       (* (- (fref (aref ti 1) tv_sec) (fref (aref ti 0) tv_sec)) 1000000000)))
                )
            )
        (load
            (:put from j1 to j2
                (%ifdef* MKTREE-PROFILE
                    (def td (array (struct timespec) 2))
                    (csym::clock-gettime CLOCK_REALTIME td)
                    )
                (= this.local-root (makecell))
                (csym::CLRV (csym::Pos this.local-root))
                (= this.traverse-root NULL)
                (= this.start j1)
                (= this.end j2)
                (%ifdef* MKTREE-PROFILE
                    (csym::clock-gettime CLOCK_REALTIME (+ td 1))
                    (+= WDATA.task-dividing-time
                        (+ (- (fref (aref td 1) tv_nsec) (fref (aref td 0) tv_nsec))
                           (* (- (fref (aref td 1) tv_sec) (fref (aref td 0) tv_sec)) 1000000000)))
                    )
                )
            (:get
                (%ifdef* MKTREE-PROFILE
                    (def tf (array (struct timespec) 2))
                    (csym::clock-gettime CLOCK_REALTIME tf)
                    )
                (mergetree local-root this.local-root rsize)
                (collectcell this.local-root)
                (%ifdef* MKTREE-PROFILE
                    (csym::clock-gettime CLOCK_REALTIME (+ tf 1))
                    (+= WDATA.fst-merging-time
                        (+ (- (fref (aref tf 1) tv_nsec) (fref (aref tf 0) tv_nsec))
                           (* (- (fref (aref tf 1) tv_sec) (fref (aref tf 0) tv_sec)) 1000000000)))
                    )
                )
            )))
        )
    )

(def (mergetree lhd rhd csize)
     (wfn void cellptr cellptr real)
    (def i int)
;    (for ((= i 0) (< i NDIM) (inc i))
;        (if (!= (aref (csym::Pos lhd) i) (aref (csym::Pos rhd) i))
;            (csym::error "mergetree: center position of cell not matched.")
;            )
;        )
    (for ((= i 0) (< i NSUB) (inc i))
        (if (== (aref (csym::Subp rhd) i) NULL)
            ; ==  rhd[i] -> NULL ==
            (begin
            (continue)
            )) 
        (if (== (aref (csym::Subp lhd) i) NULL)
            ; ==  lhd[i] -> NULL ==
            (begin
            (= (aref (csym::Subp lhd) i) (aref (csym::Subp rhd) i))
            (continue)
            ))
        (if (== (csym::Type (aref (csym::Subp lhd) i)) BODY)
            ; ==  lhd[i] -> BODY  ==
            (begin
            (if (== (csym::Type (aref (csym::Subp rhd) i)) BODY)
                ; ==  rhd[i] -> BODY  ==
                (begin
                (def c cellptr)
                (def k int)
                (def dist2 real)
                (def distv vector)
                (csym::DOTPSUBV dist2 distv
                                (csym::Pos (aref (csym::Subp lhd) i))
                                (csym::Pos (aref (csym::Subp rhd) i)))
                (if (== dist2 0.0)
                    (csym::error "loadbody: two bodies have same position~%")
                    )
                (= c (makecell))
                (for ((= k 0) (< k NDIM) (inc k))
                    (= (aref (csym::Pos c) k)
                       (+ (aref (csym::Pos lhd) k)
                          (/ (if-exp (< (aref (csym::Pos (aref (csym::Subp lhd) i)) k)
                                        (aref (csym::Pos lhd) k))
                                     (- csize) csize) 4)))
                    )
;                (for ((= k 0) (< k NDIM) (inc k))
;                    (if (or (<  (aref (csym::Pos (aref (csym::Subp lhd) i)) k) (- (aref (csym::Pos c) k) (/ csize 4)))
;                            (>= (aref (csym::Pos (aref (csym::Subp lhd) i)) k) (+ (aref (csym::Pos c) k) (/ csize 4))))
;                        (csym::error "mergetree: body is outside of cell.")
;                        )
;                    (if (or (<  (aref (csym::Pos (aref (csym::Subp rhd) i)) k) (- (aref (csym::Pos c) k) (/ csize 4)))
;                            (>= (aref (csym::Pos (aref (csym::Subp rhd) i)) k) (+ (aref (csym::Pos c) k) (/ csize 4))))
;                        (csym::error "mergetree: body is outside of cell.")
;                        )
;                    )
                (= (aref (csym::Subp c) (csym::subindex (cast bodyptr (aref (csym::Subp lhd) i)) c))
                   (aref (csym::Subp lhd) i))
                (= (aref (csym::Subp lhd) i) (cast nodeptr c))
                (loadbody (cast bodyptr (aref (csym::Subp rhd) i))
                          (cast cellptr (aref (csym::Subp lhd) i))
                          (/ csize 2.0))
                )
                ; ==  rhd[i] -> CELL  ==
                (begin
                (loadbody (cast bodyptr (aref (csym::Subp lhd) i))
                          (cast cellptr (aref (csym::Subp rhd) i))
                          (/ csize 2.0))
                (= (aref (csym::Subp lhd) i) (aref (csym::Subp rhd) i))
                ))
            )
            ; ==  lhd[i] -> CELL  ==
            (begin
            (if (== (csym::Type (aref (csym::Subp rhd) i)) BODY)
                ; ==  rhd[i] -> BODY  ==
                (begin
                (loadbody (cast bodyptr (aref (csym::Subp rhd) i))
                          (cast cellptr (aref (csym::Subp lhd) i))
                          (/ csize 2.0))
                )
                ; ==  rhd[i] -> CELL  ==
                (begin
                (mergetree (cast cellptr (aref (csym::Subp lhd) i))
                           (cast cellptr (aref (csym::Subp rhd) i))
                           (/ csize 2.0))
                (collectcell (cast cellptr (aref (csym::Subp rhd) i)))
                ))
            ))
        )
    )

)))  ; ======== end of %if ========


;------------------------------------------------------------------------------
; cofm: task definition for parallelizing hackcofm
;------------------------------------------------------------------------------

(decl (hackcofm-core p psize lev tdepth- cellhist- subnhist-)
      (wfn int cellptr real int (ptr int) (array int MAXLEVEL) (array int MAXLEVEL)))
(decl (hackcofm-for p psize lev i1 i2 update- mass- cmpos- tdepth- cellhist- subnhist-)
      (wfn int cellptr real int int int (ptr bool) (ptr real) vector (ptr int) (array int MAXLEVEL) (array int MAXLEVEL)))

(def (hackcofm p psize lev)
     (wfn void cellptr real int)
    (def ncellbody int 0)

    (= ncellbody (hackcofm-core p psize lev (ptr tdepth) cellhist subnhist))
    ;(if (!= ncellbody nbody)
    ;    (csym::error "hackcofm: number of bodies not matched.")
    ;    )
    )

(def (task cofm)
    (def p cellptr :in)
    (def psize real :in)
    (def lev int :in)
    (def i1 int :in)
    (def i2 int :in)
    (def update bool :out)
    (def mass real :out)
    (def cmpos vector :out)
    (def tdepth int :out)
    (def cellhist (array int MAXLEVEL) :out)
    (def subnhist (array int MAXLEVEL) :out)
    (def nbody int :out)
    )

(def (task-body cofm)
    (def i int)
    (= this.update FALSE)
    (= this.mass 0.0)
    (csym::CLRV this.cmpos)
    (= this.tdepth 0)
    (for ((= i 0) (< i MAXLEVEL) (inc i))
        (= (aref this.cellhist i) 0)
        (= (aref this.subnhist i) 0)
        )
    (= this.nbody
        (hackcofm-for this.p this.psize this.lev this.i1 this.i2
                      (ptr this.update) (ptr this.mass) this.cmpos (ptr this.tdepth)
                      this.cellhist this.subnhist))
    )

(def (hackcofm-core p psize lev tdepth- cellhist- subnhist-)
     (wfn int cellptr real int (ptr int) (array int MAXLEVEL) (array int MAXLEVEL))
    (def k int)
    (def cmpos vector)
    (def ncellbody int 0)
    
    (= (mref tdepth-) (csym::MAX (mref tdepth-) lev))
    (inc (aref cellhist- lev))
    (= (csym::Mass p) 0.0)
    (csym::CLRV cmpos)
    (= ncellbody
        (hackcofm-for p psize lev 0 NSUB
                      (ptr (csym::Update p)) (ptr (csym::Mass p)) cmpos tdepth-
                      cellhist- subnhist-))
    (%ifdef* COUNTBODY
        (= (fref p -> nbody) ncellbody)
        )
    (if (> (csym::Mass p) 0.0)
        (begin
        (csym::DIVVS cmpos cmpos (csym::Mass p))
        )
        (begin
        (csym::SETV cmpos (csym::Pos p))
        ))
    (for ((= k 0) (< k NDIM) (inc k))
        (if (or (< (aref cmpos k) (- (aref (csym::Pos p) k) (/ psize 2)))
                (<= (+ (aref (csym::Pos p) k) (/ psize 2)) (aref cmpos k)))
            (csym::error "hackcofm: tree structure error~%")
            )
        )
    (%ifndef QUICKSCAN ((csym::setrcrit p cmpos psize)))
    (csym::SETV (csym::Pos p) cmpos)

    (return ncellbody)
    )

(def (hackcofm-for p psize lev i1 i2 update- mass- cmpos- tdepth- cellhist- subnhist-)
     (wfn int cellptr real int int int (ptr bool) (ptr real) vector (ptr int)
              (array int MAXLEVEL) (array int MAXLEVEL))
    (def ret int 0)
    (do-many for i from i1 to i2
        (begin
        (def q nodeptr)
        (if (!= (= q (aref (csym::Subp p) i)) NULL)
            (begin
            (def tmpv vector)
            (inc (aref subnhist- lev))
            (if (== (csym::Type q) CELL)
                (begin
                (+= ret (hackcofm-core (cast cellptr q) (/ psize 2) (+ lev 1) tdepth-
                                       cellhist- subnhist-))
                )
                (begin
                (inc ret)
                ))
            (bit-or= (mref update-) (csym::Update q))
            (+= (mref mass-) (csym::Mass q))
            (csym::MULVS tmpv (csym::Pos q) (csym::Mass q))
            (csym::ADDV cmpos- cmpos- tmpv)
            ))
        )
    (cofm
        (:put from j1 to j2
        (= this.p p)
        (= this.psize psize)
        (= this.lev lev)
        (= this.i1 j1)
        (= this.i2 j2)
        )
        (:get
        (def j int)
        (bit-or= (mref update-) this.update)
        (+= (mref mass-) this.mass)
        (csym::ADDV cmpos- cmpos- this.cmpos)
        (= (mref tdepth-) (csym::MAX (mref tdepth-) this.tdepth))
        (for ((= j 0) (< j MAXLEVEL) (inc j))
            (+= (aref cellhist- j) (aref this.cellhist j))
            (+= (aref subnhist- j) (aref this.subnhist j))
            )
        (+= ret this.nbody)
        )))
    (return ret)
    )


;------------------------------------------------------------------------------
; thtree: task definition for parallelizing threadtree
;------------------------------------------------------------------------------

(def (task thtree)
    (def desc (ptr nodeptr))
    (def i1 int)
    (def i2 int)
    )

(def (task-body thtree)
    (threadtree-for this.desc this.i1 this.i2)
    )

(def (threadtree p n)
     (wfn void nodeptr nodeptr)
    (= (csym::Next p) n)
    (if (== (csym::Type p) CELL)
        (begin
        (def i int)
        (def ndesc int 0)
        (def desc (array nodeptr (+ NSUB 1)))
        
        (for ((= i 0) (< i NSUB) (inc i))
            (if (!= (aref (csym::Subp p) i) NULL)
                (= (aref desc (inc ndesc)) (aref (csym::Subp p) i))
                )
            )
        (if (> ndesc 0)
            (begin
            (= (csym::More p) (aref desc 0))
            (= (aref desc ndesc) n)
            (threadtree-for desc 0 ndesc)
            )
            (begin
            (= (csym::More p) NULL))
            )
        ))
    )

(def (threadtree-for desc i1 i2)
     (wfn void (array nodeptr (+ NSUB 1)) int int)
    (do-many for i from i1 to i2
        (threadtree (aref desc i) (aref desc (+ i 1)))
    (thtree
        (:put from j1 to j2
        (= this.desc desc)
        (= this.i1 j1)
        (= this.i2 j2)
        )
        (:get
        )))
    )

